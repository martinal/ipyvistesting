<!DOCTYPE html>
<html>
<head>

<title>WebGL2 volume renderer test</title>

<style>
    body {background-color: white;}
</style>


<script id="cellShader" type="glsl/vertex-shader">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp isampler2D;

// Contains vertex indices for each tetrahedron
uniform isampler2D u_cells;

// Contains coordinates for each vertex of the tetrahedron mesh
uniform sampler2D u_coordinates;

// Camera position used to compute view direction with perspective projection
uniform vec3 u_cameraPosition;

// Camera view direction with orthographic projection
//uniform vec3 u_viewDirection;

// Cell index taken from cell ordering
in int a_cellIndex;

void main() {
    // Get vertex indices of cell
    ivec2 cellTexSize = textureSize(u_cells, 0);
    int cellStride = cellTexSize.x; // TODO: .x or .y?
    ivec2 cellPos = ivec2(a_cellIndex / cellStride, a_cellIndex % cellStride);
    ivec4 index = texelFetch(u_cells, cellPos, 0);

    // Get vertex coordinates of cell
    vec3 coords[4];
    for (int i = 0; i < 4; ++i)
    {
        ivec2 coordsTexSize = textureSize(u_coordinates, 0);
        int indexStride = coordsTexSize.x; // TODO: .x or .y?
        ivec2 indexPos = ivec2(index[i] / indexStride, index[i] % indexStride);
        coords[i] = texelFetch(u_coordinates, indexPos, 0).xyz;
    }

    // Compute edge vectors
    // FIXME: Only need maybe 6 with a smarter selection,
    //        this is just a proof of concept
    vec3 e[16];
    for (int i = 0; i < 4; ++i)
    {
        for (int j = 0; j < 4; ++j)
        {
            e[i*4 + j] = coords[j] - coords[i];
        }
    }

    // Compute normals and plane equation coefficients
    // FIXME: Debug, quickly written and probably not correct
    vec4 n[4];
    for (int i = 0; i < 4; ++i)
    {
        // Indices of face i
        int i1 = (i + 1) & 3;
        int i2 = (i + 2) & 3;
        int i3 = (i + 3) & 3;

        // Face normal
        vec3 nn = normalize(cross(e[i1*4 + i2], e[i1*4 + i3]));
        nn = faceforward(nn, coords[i1] - coords[i], nn);

        // Plane equation coefficient
        n[i] = vec4(nn, dot(nn, coords[i1]));
    }

    // Compute ray length vectors holding distances from
    // each vertex to each plane along view direction,
    // only nonzero for vertex i / plane i
    vec4 t[4];
    for (int i = 0; i < 4; ++i)
    {
        // Arbitrary index on face i
        int i1 = (i + 1) & 3;

        // View direction through vertex i for perspective projected camera
        vec3 viewDirection = normalize(coords[i] - u_cameraPosition);

        // Normal of opposing face
        vec3 nn = n[i].xyz;

        // Only nonzero for vertex i -> face i
        t[i] = vec4(0.0f, 0.0f, 0.0f, 0.0f);

        // Ray length between vertex i and face i
        t[i][i] = dot(e[i*4 + i1], nn) / dot(viewDirection, nn);
    }

    // FIXME: Output cellIndex
    // FIXME: Output coords
    // FIXME: Output rayLength
    // FIXME: Output functionValue
    // FIXME: Output functionGradient
    // FIXME: Setup vertex transform buffers and test this
    // FIXME: Maybe split into more than one shader
}
</script>


<script id="vertexShader" type="glsl/vertex-shader">#version 300 es
precision highp float;
precision highp int;

// MVP matrix
uniform mat4 u_mvp;

// Vertex coordinate in model space
in vec3 a_position;

// Ray lengths to opposing faces
in vec4 a_rayLengths;

// Tetrahedron cell index
in int a_cellIndex;

// Value of function in vertex
in float a_functionValue;  // TODO: Name? function, value, data, etc... pick one

// Gradient of f on this cell
in vec3 a_functionGradient;

// Position in model coordinates
out vec3 v_position;

// Ray lengths to opposing faces
out vec4 v_rayLengths;

// Tetrahedron cell index
flat out int v_cellIndex;

// Value of function
out float v_functionValue;

// Gradient of f on this cell
flat out vec3 v_functionGradient;

void main()
{
    // Pass on attributes to be interpolated across front face
    v_position = a_position;
    v_rayLengths = a_rayLengths;
    v_cellIndex = a_cellIndex;
    v_functionValue = a_functionValue;
    v_functionGradient = a_functionGradient;
    gl_Position = u_mvp * vec4(a_position, 1.0);
}
</script>


<script id="fragmentShader" type="glsl/fragment-shader">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;

// Camera position used to compute view direction with perspective projection
uniform vec3 u_cameraPosition;

// Camera view direction with orthographic projection
//uniform vec3 u_viewDirection;

// Lookup table for density
uniform sampler2D u_densityLUT;

// Lookup table for emission color
uniform sampler2D u_emissionLUT;

// Particle cross section to scale extinction
uniform float u_particleCrossSection;

// Min/max values of function
uniform vec3 u_fRange;

// Position in model coordinates
in vec3 v_position;

// Ray lengths to opposing faces
in vec4 v_rayLengths;

// Value of f at current fragment on the rasterized front face
in float v_functionValue;

// Gradient of f on this cell
flat in vec3 v_functionGradient;
// TODO: Get functionGradient by sampling texture instead to save memory
//flat in int v_cellIndex;
//uniform sampler2D u_functionGradient;

// Final result
out vec4 fragColor;

vec4 integrate_constant_ray(float depth, float extinction, vec3 emission)
{
    // Simplest per-fragment approximation to ray integral, assuming
    // piecewise constant color and extinction across the ray segment.
    // Use with blend equation: I_src * A_dst + I_dst
    float transparency = exp(-depth * extinction);
    float alpha = 1.0f - transparency;
    return vec4(alpha * emission, alpha);
}

void main()
{
    // View direction through this fragment for perspective projected camera
    vec3 viewDirection = normalize(v_position - u_cameraPosition);

    // Look for smallest positive ray length
    const float infinity = 1e10;
    float depth = infinity;
    for (int i = 0; i < 4; ++i)
    {
        if (v_rayLengths[i] > 0.0f)
        {
            depth = min(depth, v_rayLengths[i]);
        }
    }

    // Compute exit position (not needed)
    //float exitPosition = v_position + depth * viewDirection;

    // Compute f values at entry and exit points of ray
    float fStart = v_functionValue;
    float fEnd = fStart + depth * dot(v_functionGradient, viewDirection);

    // Map function values to [0, 1] range
    // Optimized by defining
    //    u_fRange.z == 1.0f / (u_fRange.x - u_fRange.y);
    float f0 = (fEnd - u_fRange.x) * u_fRange.z;
    float f1 = (fStart - u_fRange.x) * u_fRange.z;

    // Use lookup tables to map (depth, f0, f1) to extinction and emission:
    vec2 f0pos = vec2(f0, 0.5f);
    vec2 f1pos = vec2(f1, 0.5f);
    float extinction0 = u_particleCrossSection * texture(u_densityLUT, f0pos).r;
    float extinction1 = u_particleCrossSection * texture(u_densityLUT, f1pos).r;
    vec3 emission0 = texture(u_emissionLUT, f0pos).xyz;
    vec3 emission1 = texture(u_emissionLUT, f1pos).xyz;
    float extinction = 0.5f * (extinction0 + extinction1);
    vec3 emission = 0.5f * (emission0 + emission1);

    fragColor = integrate_constant_ray(depth, extinction, emission);
}
</script>


<script>
function createShader(gl, type, source, errorCb) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }
    var msg = gl.getShaderInfoLog(shader);
    console.log(msg);
    errorCb(msg);
    gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader, errorCb) {
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    var success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }
    var msg = gl.getProgramInfoLog(program);
    console.log(msg);
    errorCb(msg);
    gl.deleteProgram(program);
}

function init() {
    console.log("main running");

    var precanvas = document.getElementById("precanvas");
    var canvas = document.getElementById("thecanvas");
    var gl = canvas.getContext("webgl2", {
        antialias: false,
        depth: false,
        alpha: true,
        stencil: false,
        preserveDrawingBuffer: true,
        failIfMajorPerformanceCaveat: true,
    });
    if (!gl) {
        console.log("Failed to get webGL2 context.");
        precanvas.innerHTML = "<h3>Couldn't get WebGL2 context, canvas will be empty.</h3>";
        return;
    }
    precanvas.innerHTML = "<h3>WebGL2 Canvas (size " + gl.canvas.width + " x " + gl.canvas.height + ")</h3>";


    // Configure size and background
    //webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0, 0, 0, 0);


    // Configure blend equation
    gl.blendEquation(gl.FUNC_ADD);
    //gl.blendEquation(gl.MAX);
    gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE);


    // Get shader source from page
    var cellShaderSrc = document.getElementById("cellShader").innerHTML;
    var vertexShaderSrc = document.getElementById("vertexShader").innerHTML;
    var fragmentShaderSrc = document.getElementById("fragmentShader").innerHTML;

    // Display shader sources on page
    document.getElementById("cellShaderSrcDisplay").innerHTML = cellShaderSrc;
    document.getElementById("vertexShaderSrcDisplay").innerHTML = vertexShaderSrc;
    document.getElementById("fragmentShaderSrcDisplay").innerHTML = fragmentShaderSrc;

    var cellShader = createShader(gl, gl.VERTEX_SHADER, cellShaderSrc,
        function(error) { document.getElementById("cellShaderSrcErrors").innerHTML = error; }
        );
    /*
    var cellProgram = createProgram(gl, cellShader, ...);
    */

    // Compile shaders and link program
    var vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSrc,
        function(error) { document.getElementById("vertexShaderSrcErrors").innerHTML = error; }
        );
    var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSrc,
        function(error) { document.getElementById("fragmentShaderSrcErrors").innerHTML = error; }
        );
    var program = createProgram(gl, vertexShader, fragmentShader,
        function(error) { document.getElementById("programLinkErrors").innerHTML = error; }
        );


    // Make this the active program
    gl.useProgram(program);


    // Create and bind a VAO, the following VBA calls will store data in this object
    var vao = gl.createVertexArray();
    gl.bindVertexArray(vao);



    ///////////////////////////////////////////////////////////////////////////
    // Mockup of unstructured tetrahedral mesh data
    // Define mesh coordinates
    var vertices = new Float32Array([
        0.0, 0.0, 0.0,
        0.0, 0.0, 1.0,
        0.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
        1.0, 1.0, 1.0,
    ]);
    // Define mesh cells
    var cells = new Uint32Array([
        0, 1, 2, 3,
        1, 2, 3, 4,
    ]);
    // Define mesh cell ordering
    var cellOrdering = new Uint32Array([
        1, 0
    ]);
    // Define function values in vertices
    var vertexValues = new Float32Array([
        1.0, 2.0, 3.0, 4.0, 5.0
    ]);
    ///////////////////////////////////////////////////////////////////////////
    // Get and validate dimensions from data
    var num_cells = Math.floor(cells.length / 4);
    var num_tetrahedron_vertices = Math.floor(vertices.length / 3);
    var num_triangle_vertices = num_cells * 4;
    if (cells.length !== num_cells * 4) {
        throw "Invalid dimensions.";
    }
    if (vertices.length !== num_tetrahedron_vertices * 3) {
        throw "Invalid dimensions.";
    }
    if (cellOrdering.length !== num_cells) {
        throw "Invalid dimensions.";
    }
    if (vertexValues.length !== num_tetrahedron_vertices) {
        throw "Invalid dimensions.";
    }
    ///////////////////////////////////////////////////////////////////////////
    /* Things to do:

    - Upload vertices to buffer
    - Upload cells to buffer
    - Upload ordering to buffer
    - Upload vertexvalues to buffer

    - Allocate buffer for float functionValue per vert per cell
    - Allocate buffer for vec3 functionGradient per cell (use as texture) or per vert per cell (use as vba)
    - Allocate buffer for vec4 rayLength per vert per cell
    - Allocate buffer for uint cellIndex per vert per cell (duplicated from cellOrdering)
    - Allocate buffer for vec3 position per vert per cell
    */
    // Attribute dimensions:
    /*
    gl.vertexAttribPointer(functionValueLoc, 1, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(functionGradientLoc, 3, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(rayLengthLoc, 4, gl.FLOAT, false, 0, 0);
    gl.vertexAttribPointer(cellIndexLoc, 1, gl.UINT, false, 0, 0);
    gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
    */
    ///////////////////////////////////////////////////////////////////////////


    // Upload uniform values
    var mvp = new Float32Array([
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0,
    ]);
    var mvpLocation = gl.getUniformLocation(program, "u_mvp");
    gl.uniformMatrix4fv(mvpLocation, false, mvp);

    var backgroundColor = new Float32Array([1.0, 1.0, 0.0, 1.0]);
    var backgroundColorLocation = gl.getUniformLocation(program, "u_backgroundColor");
    gl.uniform4fv(backgroundColorLocation, backgroundColor);


    // Configure and upload attribute arrays
    var positions = new Float32Array([
        0, 0,
        0, 0.8,
        0.4, 0,
    ]);
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
    gl.enableVertexAttribArray(positionAttributeLocation);
    gl.vertexAttribPointer(positionAttributeLocation,
        2, gl.FLOAT, false, 0, 0);


    // Clear background
    gl.clear(gl.COLOR_BUFFER_BIT);


    // Draw triangles
    var primitiveType = gl.TRIANGLES;
    var offset = 0;
    var count = 3;
    gl.drawArrays(primitiveType, offset, count);


    // Not sure if these deletions should be done anywhere?
    var cleanup = function() {
        gl.deleteShader(cellShader);
        gl.deleteShader(vertexShader);
        gl.deleteShader(fragmentShader);
        gl.deleteProgram(program);
    }
}
</script>


</head>
<body onload="init();">

    <div id="precanvas"></div>
    <canvas id="thecanvas" width="800" height="600"></canvas>
    <div id="shaderdisplay">
        <h3>cell shader</h3>
        <pre><code id="cellShaderSrcDisplay"></code></pre>
        <pre><code id="cellShaderSrcErrors"></code></pre>
        <h3>vertex shader</h3>
        <pre><code id="vertexShaderSrcDisplay"></code></pre>
        <pre><code id="vertexShaderSrcErrors"></code></pre>
        <h3>fragment shader</h3>
        <pre><code id="fragmentShaderSrcDisplay"></code></pre>
        <pre><code id="fragmentShaderSrcErrors"></code></pre>
        <h3>program linking</h3>
        <pre><code id="programLinkErrors"></code></pre>
    </div>

</body>
</html>