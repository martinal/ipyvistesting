<!DOCTYPE html>
<html>
<head>

<title>WebGL2 volume renderer test</title>

<style>
    body {background-color: white;}
</style>


<script id="cellShader" type="x-shader/x-vertex">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp isampler2D;

// Must be consistent across shaders
// (TODO: Find a more robust way to configure this)
#define VERTEX_BITSHIFT 28

// Contains vertex indices for each tetrahedron
uniform isampler2D u_cells;

// Contains coordinates for each vertex of the tetrahedron mesh
uniform sampler2D u_vertices;

// Contains function values for each vertex of the tetrahedron mesh
uniform sampler2D u_functionValues;

// Camera position used to compute view direction with perspective projection
uniform vec3 u_cameraPosition;

// Camera view direction with orthographic projection
//uniform vec3 u_viewDirection;

// Cell index taken from cell ordering
in int a_cellIndex;

// Output variable: Packed cell index and local vertex index for each vertex in tetrahedron
flat out ivec4 f_cellVertIndex;

// Output variable: ray length from vertex to opposing face for each vertex in tetrahedron
flat out vec4 f_rayLengths;

// Output variable: function gradient for each tetrahedron
flat out vec3 f_functionGradient;

ivec2 texelFetchCoord(int index, ivec2 size)
{
    return ivec2(index / size.x, index % size.x);
}

uvec2 texelFetchCoord(uint index, uvec2 size)
{
    return uvec2(index / size.x, index % size.x);
}

// Compute normals and plane equation coefficients
mat4 computePlaneEquations(vec3 coords[4])
{
    // FIXME: Debug, quickly written and probably not correct
    // TODO: We'll need to guarantee the orientation of the
    // tetrahedrons for the strips to work, so we can do
    // this in a smarter way
    mat4 N;
    for (int i = 0; i < 4; ++i)
    {
        // Indices of face i
        int i1 = (i + 1) & 3;
        int i2 = (i + 2) & 3;
        int i3 = (i + 3) & 3;

        // Edge vectors spanning face i
        vec3 e0 = coords[i2] - coords[i1];
        vec3 e1 = coords[i3] - coords[i1];

        // Edge vector pointing in the approximate direction of n
        vec3 ndir = coords[i1] - coords[i];

        // Normal vector of face i
        vec3 nn = normalize(cross(e0, e1));
        nn = faceforward(nn, ndir, nn);

        // Plane equation coefficient (distance of plane
        // from origin in direction of plane normal)
        float planeDistance = dot(nn, coords[i1]);

        // Store plane equation for face i
        N[i] = vec4(nn, planeDistance);
    }
    return N;
}

// Compute ray length vectors holding distances from
// each vertex to the opposing plane along view direction.
vec4 computeRayLengths(vec3 coords[4], vec3 cameraPosition, mat4 N)
{
    vec4 rayLengths;
    for (int i = 0; i < 4; ++i)
    {
        // Arbitrary index on face i
        int i1 = (i + 1) & 3;

        // Normal of opposing face
        vec3 nn = N[i].xyz;

        // One of the edge vectors from vertex i towards a vertex on face i
        vec3 edge = coords[i1] - coords[i];

        // View direction through vertex i for perspective projected camera
        vec3 viewDirection = normalize(coords[i] - cameraPosition);

        // Ray length between vertex i and face i
        rayLengths[i] = dot(edge, nn) / dot(viewDirection, nn);
    }
    return rayLengths;
}

void main()
{
    // Get vertex indices of cell
    ivec2 cellPos = texelFetchCoord(a_cellIndex, textureSize(u_cells, 0));
    ivec4 index = texelFetch(u_cells, cellPos, 0);

    // Pack cell index and local vertex index in one int
    for (int i = 0; i < 4; ++i) {
        f_cellVertIndex[i] = a_cellIndex | (i << VERTEX_BITSHIFT);
    }

    // Get vertex coordinates of cell
    ivec2 coordsTexSize = textureSize(u_vertices, 0);
    vec3 coords[4];
    for (int i = 0; i < 4; ++i)
    {
        ivec2 indexPos = texelFetchCoord(index[i], coordsTexSize);
        coords[i] = texelFetch(u_vertices, indexPos, 0).xyz;
    }

    // FIXME: Compute gradient
    for (int j = 0; j < 3; ++j) {
        f_functionGradient[j] = 0.0f;
    }

    mat4 N = computePlaneEquations(coords);
    f_rayLengths = computeRayLengths(coords, u_cameraPosition, N);
}
</script>

<script id="dummyFragmentShader" type="x-shader/x-fragment">#version 300 es
void main() {}
</script>

<script id="vertexShader" type="x-shader/x-vertex">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp isampler2D;

// Must be consistent across shaders
// (TODO: Find a more robust way to configure this)
#define VERTEX_BITSHIFT 28

// Uniforms
uniform mat4 u_mvp;     // MVP matrix

// Texture samplers
uniform isampler2D u_cells;            // Vertex indices for each tetrahedron
uniform sampler2D u_vertices;          // Vertex coordinates for each vertex of the tetrahedron mesh
uniform sampler2D u_functionValues;    // Function values for each vertex of the tetrahedron mesh
uniform sampler2D u_functionGradients; // Function gradient for each tetrahedron

// Vertex attributes
in float a_rayLength;        // Ray lengths to each face of tetrahedron
in int a_cellVertIndex;      // Packed tetrahedron cell index and local vertex index

// Varyings
out vec3 v_position;               // Position in model space coordinates
out vec4 v_rayLengths;             // Ray lengths to each face of tetrahedron
out float v_functionValue;         // Value of function
flat out vec3 v_functionGradient;  // Gradient of f on tetrahedron

out float v_debug; // Debugging variable

ivec2 texelFetchCoord(int index, ivec2 size)
{
    return ivec2(index / size.x, index % size.x);
}

void main()
{
    // Unpack cell index and local vertex index from one int
    int cellIndex = a_cellVertIndex & ((1 << VERTEX_BITSHIFT) - 1);
    int localVertexIndex = a_cellVertIndex >> VERTEX_BITSHIFT;

    // Map index to 2D position for texture lookup
    ivec2 cellPos = texelFetchCoord(cellIndex, textureSize(u_cells, 0));

    // DEBUGGING:
    // Validated:
    // cellIndex
    // localVertexIndex
    // cellPos
    // 

    // Get global vertex index
    ivec4 verticesOfCell = texelFetch(u_cells, cellPos, 0);
    int globalVertexIndex = verticesOfCell[localVertexIndex];

    // Map vertex index to 2D position for texture lookup
    ivec2 vertexPos = texelFetchCoord(globalVertexIndex,
        textureSize(u_vertices, 0));

    // Fetch position and function value in vertex from textures
    v_position = texelFetch(u_vertices, vertexPos, 0).xyz;
    v_functionValue = texelFetch(u_functionValues, vertexPos, 0).x;

    // Get function gradient for this tetrahedron
    v_functionGradient = texelFetch(u_functionGradients, cellPos, 0).xyz;

    // Place scalar raylength from vertex to opposing
    // face in the corresponing vector entry
    v_rayLengths = vec4(0.0f);
    v_rayLengths[localVertexIndex] = a_rayLength;

#if 1 // Debugging, setting coordinates
    vec4 color = vec4(0.0f);
    color[verticesOfCell[3]] = 1.0f;

    int found = 0;
    v_debug = 0.0f; //float(globalVertexIndex - localVertexIndex);
    for (int i=0; i<4; ++i)
    {
        // DEBUGGING: This hits 1 time for one vertex and twice for two vertices
        if (globalVertexIndex == verticesOfCell[i])
        {
            found++;
            v_debug = float(i) / 3.0f;
        }
    }
    if (found == -1)
        v_debug = 0.0f;
    v_debug = color[localVertexIndex];

    if (all(equal(verticesOfCell, ivec4(0, 0, 0, 1))))
        v_debug = 1.0; // this is the case
    else
        v_debug = 0.0;

    // Setting position from this mesh confirms that
    // cellindex and localvertexindex is correct!
    mat4x3 mesh = mat4x3(
        -1.0,  0.0, 0.0,
         0.0, -1.0, 0.0,
        +1.0,  0.0, 0.0,
         0.0, +1.0, 1.0
        //0.5, 0.5, 0.5
    );
    v_position = vec3(0.2*float(cellIndex)) + mesh[localVertexIndex].xyz;
#endif

    // Map vertex coordinate to clip space
    //gl_Position = vec4(v_position, 1.0f);
    gl_Position = u_mvp * vec4(v_position, 1.0f);
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">#version 300 es
precision highp float;
precision highp int;
precision highp sampler2D;

// Camera position used to compute view direction with perspective projection
uniform vec3 u_cameraPosition;

// Camera view direction with orthographic projection
//uniform vec3 u_viewDirection;

// Particle cross section to scale density with to get extinction
uniform float u_particleCrossSection;

// Min/max values of function, .x=min, .y=max, .z=1/(max-min) or 1 if equal
uniform vec3 u_functionRange;

// Lookup table for density
uniform sampler2D u_densityLUT;

// Lookup table for emission color
uniform sampler2D u_emissionLUT;

// Lookup table for emission color (rgb) and density (a)
//uniform sampler2D u_emissionDensityLUT

// Varyings, interpolated on the rasterized front face currently drawn
in vec3 v_position;               // Position in model space coordinates
in vec4 v_rayLengths;             // Ray lengths to each face of tetrahedron
in float v_functionValue;         // Value of function
flat in vec3 v_functionGradient;  // Gradient of f on tetrahedron

in float v_debug; // Debugging variable

// Final result
out vec4 fragColor;


vec4 integrate_constant_ray(
    float depth,
    vec3 emission,
    float extinction)
{
    // Simplest per-fragment approximation to ray integral, assuming
    // piecewise constant color and extinction across the ray segment.

    // Evaluate ray integral, use in combination
    // with blend equation: RGB_src * A_dst + RGB_dst
    float transparency = exp(-depth * extinction);
    float alpha = 1.0f - transparency;
    return vec4(alpha * emission, alpha);
}

float smallestPositive(vec4 lengths)
{
    //const float infinity = 1e38f;
    bool setOnce = false;
    float depth = 0.0f;
    for (int i = 0; i < 4; ++i)
    {
        if (lengths[i] > 0.0f)
        {
            if (!setOnce)
                depth = lengths[i];
            else
                depth = min(depth, lengths[i]);
        }
    }
    return depth;
}

// Compute f values at entry and exit points of ray
vec2 computeFunctionValues(
    float functionValue, vec3 functionGradient,
    float depth, vec3 viewDirection)
{
    float functionDiff = depth * dot(functionGradient, viewDirection);
    return vec2(functionValue, functionValue + functionDiff);
}

// Map components of values from [range.x,range.y] to [0, 1],
// optimized by expecting range.z == 1.0f / (range.x - range.y)
vec2 mapToRange(vec2 values, vec3 range)
{
    return (values - vec2(range.x)) * range.z;
}

void main()
{
    // View direction through this fragment for perspective projected camera
    vec3 viewDirection = normalize(v_position - u_cameraPosition);

    // View direction through this fragment for orthographic projection camera
    //vec3 viewDirection = u_viewDirection;


    // Look for smallest positive ray length
    float depth = smallestPositive(v_rayLengths); // FIXME: Doesnt seem to work


    // Compute function values at entry and exit points of ray
    vec2 f = computeFunctionValues(
        v_functionValue, v_functionGradient,
        depth, viewDirection);

    // Map function values to [0,1] range
    f = mapToRange(f, u_functionRange);


    // Use combined lookup table favg -> (emission, extinction)
    /*
    float favg = 0.5f * (f.x + f.y);

    vec4 value = texture(u_emissionDensityLUT, vec2(favg, 0.5f));
    vec3 emission = value.rgb;
    float extinction = u_particleCrossSection * value.a;

    //vec4 ee = lookup_ee(favg, u_emissionDensityLUT, u_particleCrossSection);
    */

    // Use lookup tables to map (depth, f0, f1) to extinction and emission:
    /*
    // Use combined lookup table f -> (emission, extinction)
    vec4 value0 = texture(u_emissionDensityLUT, vec2(f0, 0.5f));
    vec4 value1 = texture(u_emissionDensityLUT, vec2(f1, 0.5f));
    vec3 emission0 = value0.rgb;
    vec3 emission1 = value1.rgb;
    float extinction0 = u_particleCrossSection * value0.a;
    float extinction1 = u_particleCrossSection * value1.a;
    // Compute averages on ray segment
    vec3 emission = mix(emission0, emission1, 0.5f);
    float extinction = mix(extinction0, extinction1, 0.5f);

    //vec4 ee = lookup_ee(f, u_emissionDensityLUT, u_particleCrossSection);
    */

    // Use separate lookup tables f -> emission, g -> extinction
    ///*
    vec2 g = f;
    vec3 emission0 = texture(u_emissionLUT, vec2(f.x, 0.5f)).rgb;
    vec3 emission1 = texture(u_emissionLUT, vec2(f.y, 0.5f)).rgb;
    float extinction0 = u_particleCrossSection * texture(u_densityLUT, vec2(g.x, 0.5f)).a;
    float extinction1 = u_particleCrossSection * texture(u_densityLUT, vec2(g.y, 0.5f)).a;
    // Compute averages on ray segment
    vec3 emission = mix(emission0, emission1, 0.5f);
    float extinction = mix(extinction0, extinction1, 0.5f);

    //vec4 ee = lookup_ee(f, g, u_emissionDensityLUT, u_particleCrossSection);
    //*/

    // Alternative models:
    // - No lookup, emission and extinction both constant
    // - Lookup only emission, extinction a constant rate
    // - Lookup only extinction, emission a constant color
    // - Lookup both emission and extinction in one LUT
    // - Lookup emission and extinction in separate LUTs
    //   using separate functions: f -> emission, g -> extinction

    // Alternative LUT organization:
    // - Lookup once using favg
    //vec4 value = texture(u_emissionDensityLUT, vec2(0.5f*(f0+f1), 0.5f));
    // - Lookup at endpoints
    //vec4 value0 = texture(u_emissionDensityLUT, vec2(f0, 0.5f));
    //vec4 value1 = texture(u_emissionDensityLUT, vec2(f1, 0.5f));
    // - Lookup in 2D texture using (f0, f1)
    //vec4 value = texture(u_emissionDensityLUT, vec2(f0, f1));


    // Apply piecewise constant ray integration model
    vec4 C = integrate_constant_ray(depth, emission, extinction);

    // Debugging:
    if (depth == 0.0f) {
        C.r = 0.0f;
        C.b = 0.0f;
    }
    //if (abs(v_debug) > 0.0f) C.g = 1.0f;
    C.g = v_debug;
    C.a = 1.0f; // ensure it's not transparent

    fragColor = C;
}
</script>

<script type="comments">
// Alternative ray models:

// - Maximum intensity:
//    - I(D) = f( sup_s f(s) )
//    - Depth buffer: Off
//    - Blend equation: Max(I_src, I_dst)
//    - Cell ordering: No
//    - Variants:
//        - Direct one phase:
//             fragColor = u_emissionColor * max(f0, f1);
//        - Direct two phase:
//             fragColor = max(f0, f1);
//             Compose framebuffer with colormap in separate phase
//        - Indirect two phase (scalar intensitymap f -> R):
//             fragColor = max(intensitymap(f0), intensitymap(f1));
//             Compose framebuffer with colormap in separate phase
//        - Indirect one phase (saturates color?, colormap f -> rgb):
//             fragColor = max(colormap(f0), colormap(f1));

// - Splatting:
//    - I(D) = int_0^D C(f(s)) ds
//    - Depth buffer: Off
//    - Blend equation: Sum(I_src, I_dst)
//    - Cell ordering: No
//    - fragColor = depth * texture(u_colormap, vec2(0.5f*(f0+f1), 0.5f)).rgb;

// - Isosurfaces:
//    - Let F = { f_i } be a discrete set of function values
//    - Let C(f) be a colormap
//    - Visible isosurface fragment is C(f(z)) for closest z where f(z) in F
//         I(D) = C( f( sup_s f(s) in F ) )
//    - "Arbitrary" number of opaque surfaces using texture:
//         isoValue[f0,f1] = first isosurface value in [f0,f1] (closest to f0)
//         isoColor[f0,f1] = colormap(isoValue[f0,f1])  // Precomposed
//    - What if we want to color with another function?
//         I(D) = C( g( sup_s f(s) in F ) )
//         isoDist[f0,f1] = distance from f0 (z=0) towards f1 (z=1) of isoValue[f0,f1]
//         s = isoDist[f0,f1]
//         g = (1-s)*g0 + s*g1
//         fragColor = colormap(g)
//    - Depth buffer: On
//    - Blend equation: Off
//    - Cell ordering: No
//    - Still need ray length to compute f1
//    - Create texture:  u_isosurface[f0, f1] = first isosurface value in [f0,f1]
//    - vec4 texel = texture(u_isosurface, vec2(f0, f1));
//    - Variants:
//        - Isosurface texture precomposed with colormap:
//            fragColor = texel;
//        - Compose with colormap:
//            fragColor = texture(u_colormap, texel.x);

// - Direct volume rendering:
//    - T(s) = exp(-int_s^D tau rho(g(t)) dt)
//    - I(D) = I(0) T(0) + int_0^D C(f(s)) rho(g(s)) T(s) ds
//    - Depth buffer: Off (can use depth test to preserve opaque background)
//    - Blend equation: (1 - A_dst) * I_src + I_dst
//    - Cell ordering: Yes
//    - Variants: (I), (II), (III) below

// - (I) Fully piecewise constant emission and extinction (current)
//   - Note: If f is also piecewise constant, don't need gradient and f0 == f1

// - (II) Piecewise linear emission and extinction (Mooreland)

// - (III) Arbitrary extinction transfer function with 2D texture lookup
//   - Assuming piecewise constant C,
//        int_0^D C rho exp(-int_s^D A rho dt) ds
//        = C int_0^D d/ds exp(-int_s^D A rho dt) ds
//        = C (exp(-int_D^D A rho dt) - exp(-int_0^D A rho dt))
//        = C (1 - T)
//        T = exp(-A int_0^D rho dt)
//   - Using f = (1-r)f0 + r f1, r in [0,1]:
//        r = t/D,  1-r = 1-t/D,  dr = 1/D dt,  r(t=s) = s/D,  r(t=D) = 1
//        U = int_0^D rho(f(t)) dt
//          = int_0^D rho( (1 - t/D)*f0 + (t/D)*f1 ) dt
//          = D int_0^1 rho( (1-r)*f0 + r*f1 ) dr
//   - Preintegrating R(f0,f1) = int_0^1 rho( (1-r)*f0 + r*f1 ) dr
</script>


<script>
function showCompileError(msg) {
    console.log(msg);
    let disp = document.getElementById("shaderdisplay");
    if (!!disp) {
        disp.style.display = "block";
        let elm = document.getElementById("shaderCompileErrors");
        if (!!elm) {
            elm.textContent = msg;
        }
    }
}

function createShader(gl, type, source) {
    let shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (success) {
        return shader;
    }
    let msg = gl.getShaderInfoLog(shader);
    showCompileError(msg);
    gl.deleteShader(shader);
}

function createProgram(gl, vertexShader, fragmentShader) {
    let program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    let success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (success) {
        return program;
    }
    let msg = gl.getProgramInfoLog(program);
    showCompileError(msg);
    gl.deleteProgram(program);
}
</script>


<script>

// Initial draft of a volumetric model class.
// This will need to accomodate missing cellOrdering,
// missing function values, additional function values,
// and partial updates.
function VolumeModel(vertices, cells, cellOrdering, functionValues)
{
    this.vertices = vertices,
    this.cells = cells;
    this.cellOrdering = cellOrdering;
    this.functionValues = functionValues;
    this.num_tetrahedrons = Math.floor(cells.length / 4);
    this.num_vertices = Math.floor(vertices.length / 3);

    let num_triangle_vertices = this.num_tetrahedrons * 4;
    if (cells.length !== 4 * this.num_tetrahedrons) {
        throw "Invalid dimensions.";
    }
    if (vertices.length !== 3 * this.num_vertices) {
        throw "Invalid dimensions.";
    }
    if (cellOrdering.length !== this.num_tetrahedrons) {
        throw "Invalid dimensions.";
    }
    if (functionValues.length !== this.num_vertices) {
        throw "Invalid dimensions.";
    }

    // Mock lookup tables
    let lutWidth = 512;
    this.densityLUT = new Float32Array(lutWidth);
    this.emissionLUT = new Float32Array(lutWidth);
    for (let i=0; i<lutWidth; ++i) {
        s = i / (lutWidth-1);
        this.densityLUT[i] = 0.3 + 0.7*s;
        this.emissionLUT[3*i + 0] = s;
        this.emissionLUT[3*i + 1] = 1.0 - s;
        this.emissionLUT[3*i + 2] = 0.0;
    }
}

// Create test model with unstructured tetrahedral mesh data
function createTestModel1() {
    let vertices = new Float32Array([
        0.5, 0.5, 0.5,
        0.0, 0.0, 1.0,
        0.0, 1.0, 0.0,
        1.0, 0.0, 0.0,
    ]);
    let cells = new Uint32Array([
        0, 1, 2, 3,
    ]);
    let cellOrdering = new Uint32Array([
        0
    ]);
    let functionValues = new Float32Array([
        0.1, 0.2, 0.3, 0.4
    ]);
    return new VolumeModel(vertices, cells, cellOrdering, functionValues);
}

function createTestModel2() {
    let vertices = new Float32Array([
        -1.0, 0.0, 0.0,
        0.0, 0.0, -1.0,
        0.0, -1.0, 0.0,
        -1.0, 0.0, 0.0,
        -1.0, -1.0, -1.0,
    ]);
    let cells = new Uint32Array([
        0, 1, 2, 3,
        1, 2, 3, 4,
    ]);
    let cellOrdering = new Uint32Array([
        1, 0
    ]);
    let functionValues = new Float32Array([
        0.1, 0.2, 0.5, 0.8, 1.0
    ]);
    return new VolumeModel(vertices, cells, cellOrdering, functionValues);
}

function ModelBuffers(model) {
    this.model = model;
}

function setupCellShaderInputs() {
    // FIXME: Setup cell shader uniforms and attributes:
}

function setupVertexShaderInputs() {
    // FIXME: Setup vertex shader uniforms and attributes:
}

</script>


<script>
// Mirror of THREE.BufferAttribute
function BufferAttribute(array, itemSize)
{
    this.array = array;
    this.count = array.length / itemSize;
    this.itemSize = itemSize;
    this.dynamic = false;
}
</script>


<script>

// Generate set of shaders  // TODO: Allow configuration
function generateShaders() {
    let cellShaderSrc = document.getElementById("cellShader").textContent;
    let dummyFragmentShaderSrc = document.getElementById("dummyFragmentShader").textContent;
    let vertexShaderSrc = document.getElementById("vertexShader").textContent;
    let fragmentShaderSrc = document.getElementById("fragmentShader").textContent;

    return {
        cellShaderSrc: cellShaderSrc,
        dummyFragmentShaderSrc: dummyFragmentShaderSrc,
        vertexShaderSrc: vertexShaderSrc,
        fragmentShaderSrc: fragmentShaderSrc
    };
}


// Compile shaders and link programs
function compilePrograms(gl, shaders) {
    // Build cell program
    let cellShader = createShader(gl, gl.VERTEX_SHADER, shaders.cellShaderSrc);
    let dummyFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, shaders.dummyFragmentShaderSrc);
    // 
    let program = gl.createProgram();
    gl.attachShader(program, cellShader);
    gl.attachShader(program, dummyFragmentShader);
    gl.transformFeedbackVaryings(program,
        ["f_cellVertIndex", "f_rayLengths", "f_functionGradient"],
        gl.SEPARATE_ATTRIBS);
    gl.linkProgram(program);
    let success = gl.getProgramParameter(program, gl.LINK_STATUS);
    if (!success) {
        let msg = gl.getProgramInfoLog(program);
        showCompileError(msg);
        gl.deleteProgram(program);
        throw "Failed to compile";
    }
    //let cellProgram = createProgram(gl, cellShader, dummyFragmentShader);
    let cellProgram = program;

    // Build vertex program
    let vertexShader = createShader(gl, gl.VERTEX_SHADER, shaders.vertexShaderSrc);
    let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, shaders.fragmentShaderSrc);
    let vertexProgram = createProgram(gl, vertexShader, fragmentShader);

    return {
        cellProgram: cellProgram,
        vertexProgram: vertexProgram
    };
}

function createSizedBuffer(gl, size, usage) {
    let buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, size, usage);
    return buffer;
}

function createAndBufferData(gl, array, usage) {
    let buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, array, usage);
    return buffer;
}

function updateBufferData(gl, buffer, array) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, array, usage);
}

// Compute the element array indices for one triangle strip for each tetrahedron
function computeElementArrayIndices(num_tetrahedrons) {
    let strip = new Uint32Array([0,1,2,3,0,1]);
    let array = new Uint32Array((strip.length + 1) * num_tetrahedrons);
    let primitiveRestartIndex = 0xFFFFFFFF;
    for (let i = 0, celloffset = 0, vertoffset = 0;
         i < num_tetrahedrons;
         ++i, celloffset += 7, vertoffset += 4)
    {
        for (let j = 0; j < 6; ++j)
            array[celloffset + j] = vertoffset + strip[j];
        array[celloffset + 6] = primitiveRestartIndex;
    }
    return array;
}

function createElementArrayBuffer(gl, elementArray) {
    let buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elementArray, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    return buffer;
}

function configureAttrib(gl, program, buffer, name, size, type) {
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    let location = gl.getAttribLocation(program, name);
    if (location < 0) {
        console.log("Failed to configure attribute:");
        console.log("WebGL error: " + gl.getError());
        console.log("Program: " + program);
        console.log("Name: " + name);
        console.log("Loc: " + location);
        console.log("GL errors: ");
    }
    else {
        gl.enableVertexAttribArray(location);
        if (type === gl.INT || type === gl.UNSIGNED_INT) {
            gl.vertexAttribIPointer(location, size, type, 0, 0);
        }
        else {
            gl.vertexAttribPointer(location, size, type, false, 0, 0);
        }
    }
}

function uploadUniforms(gl, program, uniforms) {
    let cameraPositionLocation = gl.getUniformLocation(program, "u_cameraPosition");
    if (cameraPositionLocation != -1) {
        gl.uniform3fv(cameraPositionLocation, uniforms.cameraPosition);
    }

    let viewDirectionLocation = gl.getUniformLocation(program, "u_viewDirection");
    if (viewDirectionLocation != -1) {
        gl.uniform3fv(viewDirectionLocation, uniforms.viewDirection);
    }

    let functionRangeLocation = gl.getUniformLocation(program, "u_functionRange");
    if (functionRangeLocation != -1) {
        gl.uniform3fv(functionRangeLocation, uniforms.functionRange);
    }

    let particleCrossSectionLocation = gl.getUniformLocation(program, "u_particleCrossSection");
    if (particleCrossSectionLocation != -1) {
        gl.uniform1f(particleCrossSectionLocation, uniforms.particleCrossSection);
    }

    let mvpLocation = gl.getUniformLocation(program, "u_mvp");
    if (mvpLocation != -1) {
        gl.uniformMatrix4fv(mvpLocation, false, uniforms.mvp);
    }
    console.log("Uniform locations:");
    console.log("cp:" + cameraPositionLocation + " " + uniforms.cameraPosition);
    console.log("vd:" + viewDirectionLocation + " " + uniforms.viewDirection);
    console.log("fr:" + functionRangeLocation + " " + uniforms.functionRange);
    console.log("ps:" + particleCrossSectionLocation + " " + uniforms.particleCrossSection);
    console.log("mv:" + mvpLocation + " " + uniforms.mvp);
}

// Allocate textures (simplified version, many options not available here)
function createTexture(gl, unit, buffer, internalFormat, width, height, format, type) {
    let texture = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0 + unit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);
    //gl.texStorage2D(gl.TEXTURE_2D, 1, internalFormat, width, height);
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, format, type, 0);
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    return texture;
}

function setup(gl) {

    // Configure size and background
    //webglUtils.resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0.8, 0.8, 0.8, 1.0);
    gl.enable(gl.BLEND);
    //gl.enable(gl.DEPTH_TEST);

    // Generate shader sources
    let shaders = generateShaders();

    // Compile programs
    let programs = compilePrograms(gl, shaders);

    // Create VAOs for each program
    let vaos = {
        cellVao: gl.createVertexArray(),
        vertexVao: gl.createVertexArray()
    };

    // Collect state in global volren object
    // (for now, figure out better design later)
    let volren = {}
    volren.gl = gl;
    volren.programs = programs;
    volren.vaos = vaos;
    volren.config = {
        rayModel: "dvr",
    };

    // Create test model emulating user input
    volren.model = createTestModel1();
    console.log(volren.model);

    // Create buffers for uploading model to GPU
    let NC = volren.model.num_tetrahedrons;
    let NV = 4 * NC;
    let NC4b = 4*NC;  // 4 byte value per cell
    let NV4b = 4*NV;  // 4 byte value per vertex
    volren.buffers = {
        // Upload user provided data (tex_ = texture buffers only, data per original vertex)
        tex_vertices: createAndBufferData(gl, volren.model.vertices, gl.STATIC_DRAW),
        tex_cells: createAndBufferData(gl, volren.model.cells, gl.STATIC_DRAW),
        tex_functionValues: createAndBufferData(gl, volren.model.functionValues, gl.DYNAMIC_DRAW),
        cellIndex: createAndBufferData(gl, volren.model.cellOrdering, gl.DYNAMIC_DRAW),

        // Allocate space on GPU for cell/vertex attribute buffers without uploading anything
        tex_functionGradient: createSizedBuffer(gl, 3*NC4b, gl.STATIC_DRAW),
        rayLengths: createSizedBuffer(gl, NV4b, gl.DYNAMIC_DRAW),
        cellVertIndex: createSizedBuffer(gl, NV4b, gl.DYNAMIC_DRAW),

        // Lookup tables
        tex_densityLUT: createAndBufferData(gl, volren.model.densityLUT, gl.DYNAMIC_DRAW),
        tex_emissionLUT: createAndBufferData(gl, volren.model.emissionLUT, gl.DYNAMIC_DRAW),
    };

    // Build the facet elements buffer
    volren.elementArray = computeElementArrayIndices(NC);
    volren.elementArrayBuffer = createElementArrayBuffer(gl, NC, volren.elementArray);

    // Define uniforms
    volren.uniforms = {
        mvp: new Float32Array([
            1.0, 0.0, 0.0, 0.0,
            0.0, 1.0, 0.0, 0.0,
            0.0, 0.0, 1.0, 0.0,
            0.0, 0.0, 0.0, 1.0,
        ]),
        cameraPosition: new Float32Array([0.0, 0.0, -10.0]),  // FIXME: This is suspect
        viewDirection: new Float32Array([0.0, 0.0, 1.0]),
        particleCrossSection: 1.0,
        functionRange: new Float32Array([0.0, 1.0, 1.0 / (1.0 - 0.0)]),
    };

    // FIXME: Compute texture sizes from number of tetrahedrons and vertices
    //let NC = volren.model.num_tetrahedrons;
    //let NV = volren.model.num_vertices;
    let cellTexWidth = 256;
    let cellTexHeight = 256;
    let vertexTexWidth = 256;
    let vertexTexHeight = 256;
    if (cellTexWidth * cellTexHeight < NC) {
        throw "Hardcoded texture size is too small.";
    }
    if (vertexTexWidth * vertexTexHeight < NV) {
        throw "Hardcoded texture size is too small.";
    }
    let lutWidth = volren.model.densityLUT.length;

    let cellsTexture = createTexture(gl, 0, volren.buffers.tex_cells,
        gl.R32UI, cellTexWidth, cellTexHeight, gl.RED_INTEGER, gl.UNSIGNED_INT);
    let verticesTexture = createTexture(gl, 1, volren.buffers.tex_cells,
        gl.RGB32F, vertexTexWidth, vertexTexHeight, gl.RGB, gl.FLOAT);
    let functionValuesTexture = createTexture(gl, 2, volren.buffers.tex_functionValues,
        gl.R32F, vertexTexWidth, vertexTexHeight, gl.RED, gl.FLOAT);
    let functionGradientTexture = createTexture(gl, 3, volren.buffers.tex_functionGradient,
        gl.RGB32F, cellTexWidth, cellTexHeight, gl.RGB, gl.FLOAT);
    let densityTexture = createTexture(gl, 4, volren.buffers.tex_densityLUT,
        gl.R32F, lutWidth, 1, gl.RED, gl.FLOAT);
    let emissionTexture = createTexture(gl, 5, volren.buffers.tex_emissionLUT,
        gl.RGB32F, lutWidth, 1, gl.RGB, gl.FLOAT);

    // Setup feedback transform stuff FIXME: validate
    console.log("Configuring cell program...");
    program = volren.programs.cellProgram;
    vao = volren.vaos.cellVao;
    gl.useProgram(program);
    gl.bindVertexArray(vao);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    uploadUniforms(gl, program, volren.uniforms);
    // Configure textures for cell program
    let cellsTextureLocation2 = gl.getUniformLocation(program, "u_cells")
    gl.uniform1i(cellsTextureLocation2, 0);
    let verticesTextureLocation = gl.getUniformLocation(program, "u_vertices")
    gl.uniform1i(verticesTextureLocation, 1);
    let functionValuesTextureLocation = gl.getUniformLocation(program, "u_functionValues")
    gl.uniform1i(functionValuesTextureLocation, 2);
    // Configure attributes for cell program
    configureAttrib(gl, program, volren.buffers.cellIndex,
            "a_cellIndex", 1, gl.INT);

    // Configure transform feedback stuff for cell shader FIXME: Validate
    let transformFeedback = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedback);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, volren.buffers.cellVertIndex);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, volren.buffers.rayLengths);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, volren.buffers.tex_functionGradient);
    gl.enable(gl.RASTERIZER_DISCARD);
    gl.beginTransformFeedback(gl.POINTS);
    gl.drawArrays(gl.POINTS, 0, volren.model.num_tetrahedrons);
    gl.endTransformFeedback();
    gl.disable(gl.RASTERIZER_DISCARD);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 1, null);
    gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 2, null);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

    // Select program and vao to configure attributes
    console.log("Configuring vertex program...");
    program = volren.programs.vertexProgram;
    vao = volren.vaos.vertexVao;
    gl.useProgram(program);
    gl.bindVertexArray(vao);
    uploadUniforms(gl, program, volren.uniforms);
    // Configure textures for vertex program
    let cellsTextureLocation = gl.getUniformLocation(program, "u_cells")
    gl.uniform1i(cellsTextureLocation, 0);
    let verticesTextureLocation2 = gl.getUniformLocation(program, "u_vertices")
    gl.uniform1i(verticesTextureLocation2, 1);
    let functionValuesTextureLocation2 = gl.getUniformLocation(program, "u_functionValues")
    gl.uniform1i(functionValuesTextureLocation2, 2);
    let functionGradientsTextureLocation = gl.getUniformLocation(program, "u_functionGradients")
    gl.uniform1i(functionGradientsTextureLocation, 3);
    let densityLUTTextureLocation = gl.getUniformLocation(program, "u_densityLUT")
    gl.uniform1i(densityLUTTextureLocation, 4);
    let emissionLUTTextureLocation = gl.getUniformLocation(program, "u_emissionLUT")
    gl.uniform1i(emissionLUTTextureLocation, 5);
    // Configure attributes for vertex program
    configureAttrib(gl, program, volren.buffers.rayLengths,
        "a_rayLength", 1, gl.FLOAT);
    configureAttrib(gl, program, volren.buffers.cellVertIndex,
            "a_cellVertIndex", 1, gl.INT);

    console.log("Done configuring programs...");


    // Future contents of render():

    // Draw triangles
    configureBlendEquation(gl, volren.config.rayModel);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(volren.programs.vertexProgram);
    gl.bindVertexArray(volren.vaos.vertexVao);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, volren.elementArrayBuffer);

    // DEBUGGING:
    console.log(volren.elementArray.length);
    console.log(volren.elementArrayBuffer);
    console.log(volren.model.num_tetrahedrons + "  " + (7*volren.model.num_tetrahedrons));
    console.log(volren.elementArray);
    gl.lineWidth(10.0);
    gl.drawArrays(gl.LINE_LOOP, 0, 4);

    //gl.drawElements(gl.TRIANGLE_STRIP, 3, gl.UNSIGNED_INT, 0);
    //gl.drawElements(gl.TRIANGLE_STRIP, volren.elementArray.length, gl.UNSIGNED_INT, 0);
    //gl.drawElements(gl.TRIANGLE_STRIP, 7 * volren.model.num_tetrahedrons, gl.UNSIGNED_INT, 0);

    // Return context
    return volren;
}

function configureBlendEquation(gl, rayModel) {
    switch (rayModel)
    {
    case "dvr":
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_DST_ALPHA);
        break;
    case "sum":
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE);
        break;
    case "max":
        gl.blendEquation(gl.MAX);
        break;
    case "min":
        gl.blendEquation(gl.MIN);
        break;
    default:
        console.log("Unknown ray model " + rayModel);
    }
}

function render(volren) {
    //console.log("Rendering...");

    gl = volren.gl;

    // Process tetrahedron cells
    //gl.useProgram(volren.programs.cellProgram);
    //gl.bindVertexArray(volren.vaos.cellVao);
    //gl.drawArrays(gl.POINTS, 0, volren.model.num_tetrahedrons);

    // Draw triangles
    gl.useProgram(volren.programs.vertexProgram);
    gl.bindVertexArray(volren.vaos.vertexVao);
    configureBlendEquation(gl, volren.config.rayModel);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLES, 0, 4 * volren.model.num_tetrahedrons);

    //console.log("Done rendering...");
}

function update(volren) {
    // Using global object volren
    //window.requestAnimationFrame(update.bind(null, volren));
    //render(volren);
}

function init()
{
    let canvas = document.getElementById("webgl2canvas");
    let gl = canvas.getContext("webgl2", {
        antialias: false,
        depth: false,
        alpha: true,
        stencil: false,
        preserveDrawingBuffer: true,
        failIfMajorPerformanceCaveat: true,
    });
    if (!gl) {
        console.log("Failed to get webGL2 context.");
        return;
    }

    // Initial gl setup
    let volren = setup(gl);

    // Start updates
    update(volren);
}
</script>

</head>
<body onload="init();">
    <canvas id="webgl2canvas" width="800" height="600"></canvas>
    <div id="shaderdisplay" style="display:none;">
        <h3>shader compile/link errors</h3>
        <pre><code id="shaderCompileErrors">No errors.</code></pre>
    </div>
</body>
</html>